# Guide de Migration Supabase vers Backend Custom + D√©ploiement AWS

## üìã Table des Mati√®res

1. [Analyse de l'Architecture Actuelle](#analyse-de-larchitecture-actuelle)
2. [R√©ponse √† Vos Questions](#r√©ponse-√†-vos-questions)
3. [Option 1 : Migration Compl√®te](#option-1--migration-compl√®te)
4. [Option 2 : Architecture Hybride](#option-2--architecture-hybride)
5. [Contrats API pour l'√âquipe Backend](#contrats-api-pour-l√©quipe-backend)
6. [Guide de Migration Supabase ‚Üí Backend Custom](#guide-de-migration-supabase--backend-custom)
7. [D√©ploiement AWS](#d√©ploiement-aws)
8. [Checklist de Migration](#checklist-de-migration)

---

## üèóÔ∏è Analyse de l'Architecture Actuelle

### Ce qui a √©t√© construit

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ARCHITECTURE ACTUELLE                 ‚îÇ
‚îÇ                  (Supabase Full-Stack)                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  FRONTEND (React + Vite)                                ‚îÇ
‚îÇ  ‚îú‚îÄ Components                                          ‚îÇ
‚îÇ  ‚îú‚îÄ Services (appels directs √† Supabase)               ‚îÇ
‚îÇ  ‚îî‚îÄ Hooks                                               ‚îÇ
‚îÇ                    ‚Üì ‚Üì ‚Üì                                ‚îÇ
‚îÇ           Supabase Client SDK                           ‚îÇ
‚îÇ                    ‚Üì ‚Üì ‚Üì                                ‚îÇ
‚îÇ  SUPABASE (Backend-as-a-Service)                        ‚îÇ
‚îÇ  ‚îú‚îÄ PostgreSQL Database                                ‚îÇ
‚îÇ  ‚îú‚îÄ Auth (JWT)                                          ‚îÇ
‚îÇ  ‚îú‚îÄ Row Level Security (RLS)                           ‚îÇ
‚îÇ  ‚îú‚îÄ Edge Functions                                      ‚îÇ
‚îÇ  ‚îî‚îÄ Real-time subscriptions                            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ‚ö†Ô∏è Question Cl√© : Est-ce un Monorepo ?

**NON**, ce n'est PAS un monorepo classique. C'est un **Frontend qui utilise Supabase comme Backend**.

```
Structure actuelle :
trophenix/
‚îú‚îÄ src/ (Frontend React)
‚îú‚îÄ supabase/ (Migrations SQL uniquement)
‚îî‚îÄ package.json (Frontend)

Ce n'est PAS :
trophenix/
‚îú‚îÄ packages/
‚îÇ  ‚îú‚îÄ frontend/
‚îÇ  ‚îî‚îÄ backend/
```

**Donc vous avez :**
- ‚úÖ Frontend React (ce repo)
- ‚ùå Pas de backend custom (Supabase = backend)

---

## üí° R√©ponse √† Vos Questions

### Q1 : "Si nous avons d√©j√† un backend, comment faire ?"

**R√©ponse** : Vous avez **3 options** :

#### **Option A : Remplacer Supabase par votre backend** ‚≠ê RECOMMAND√â

```
AVANT :
Frontend ‚Üí Supabase

APR√àS :
Frontend ‚Üí Votre Backend API ‚Üí Votre DB
```

**Avantages** :
- ‚úÖ Architecture propre et standard
- ‚úÖ Contr√¥le total
- ‚úÖ Pas de vendor lock-in
- ‚úÖ Int√©gration avec votre stack existante

**Inconv√©nients** :
- ‚ö†Ô∏è N√©cessite refactoring du frontend (services)
- ‚ö†Ô∏è Perte des fonctionnalit√©s Supabase (RLS auto, Real-time)
- ‚ö†Ô∏è Effort: 3-4 semaines

#### **Option B : Architecture Hybride (Temporaire)**

```
Frontend ‚Üí Votre Backend API (logique m√©tier)
        ‚Üí Supabase (auth seulement)
```

**Avantages** :
- ‚úÖ Migration progressive
- ‚úÖ Garde l'auth Supabase (simple)

**Inconv√©nients** :
- ‚ö†Ô∏è Temporaire, pas id√©al long terme
- ‚ö†Ô∏è D√©pendance √† Supabase reste

#### **Option C : Abandonner ce repo, repartir du backend existant**

```
Frontend dans votre repo backend existant
Backend API ‚Üí Votre DB
```

**Avantages** :
- ‚úÖ Coh√©rent avec votre stack

**Inconv√©nients** :
- ‚ùå Perte de tout le travail frontend
- ‚ùå Recommencer √† z√©ro

---

**üéØ RECOMMANDATION : Option A (Migration Compl√®te)**

Pourquoi ?
1. Tout le travail frontend est **r√©utilisable** (composants, logique, UI)
2. Seuls les **services** doivent √™tre modifi√©s (layer d'API)
3. Votre backend impl√©mente les m√™mes endpoints
4. Architecture standard et maintenable

---

### Q2 : "Comment l'√©quipe dev va faire avec une logique frontend et backend s'ils ont d√©j√† un backend ?"

**R√©ponse** : Votre √©quipe doit :

1. **Garder le frontend (ce repo)** ‚Üê Tout est r√©utilisable !
2. **Impl√©menter les m√™mes API dans leur backend** (voir Contrats API)
3. **Remplacer les appels Supabase par des appels API** (simple refactoring)

**Exemple concret** :

```typescript
// AVANT (avec Supabase)
const { data } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', userId);

// APR√àS (avec votre backend)
const data = await fetch(`https://api.trophenix.com/profiles/${userId}`, {
  headers: { 'Authorization': `Bearer ${token}` }
}).then(res => res.json());
```

C'est juste **remplacer les services** ! Les composants restent identiques.

### Q3 : "Est-ce qu'on peut migrer de Supabase √† AWS ?"

**OUI, absolument !** Voir section [D√©ploiement AWS](#d√©ploiement-aws)

### Q4 : "Le sch√©ma de donn√©es est-il r√©utilisable ?"

**OUI, √† 100% !** Toutes les migrations SQL dans `supabase/migrations/` sont compatibles PostgreSQL, MySQL, etc.

```bash
# Copier les migrations
cp -r supabase/migrations/ backend/migrations/

# Ex√©cuter dans votre DB
psql -h your-db.com -U user -d trophenix < migrations/*.sql
```

---

## üîÑ Option 1 : Migration Compl√®te (RECOMMAND√â)

### Architecture Cible

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ARCHITECTURE CIBLE                      ‚îÇ
‚îÇ              (Backend Custom sur AWS)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  FRONTEND (React + Vite)                                ‚îÇ
‚îÇ  ‚îú‚îÄ Components (‚úÖ inchang√©)                           ‚îÇ
‚îÇ  ‚îú‚îÄ Services (üîÑ modifi√©s pour appeler API)           ‚îÇ
‚îÇ  ‚îî‚îÄ Hooks (‚úÖ inchang√©)                                ‚îÇ
‚îÇ                    ‚Üì ‚Üì ‚Üì                                ‚îÇ
‚îÇ           Votre Backend API                             ‚îÇ
‚îÇ  ‚îú‚îÄ Node.js / Django / FastAPI / Go / etc.            ‚îÇ
‚îÇ  ‚îú‚îÄ Authentification JWT                               ‚îÇ
‚îÇ  ‚îú‚îÄ Endpoints REST ou GraphQL                          ‚îÇ
‚îÇ  ‚îî‚îÄ Business Logic                                     ‚îÇ
‚îÇ                    ‚Üì ‚Üì ‚Üì                                ‚îÇ
‚îÇ  BASE DE DONN√âES                                        ‚îÇ
‚îÇ  ‚îú‚îÄ PostgreSQL (AWS RDS)                               ‚îÇ
‚îÇ  ‚îú‚îÄ MySQL (AWS RDS)                                    ‚îÇ
‚îÇ  ‚îî‚îÄ MongoDB / autre...                                 ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### √âtapes de Migration

#### √âtape 1 : Conserver le sch√©ma de donn√©es

Le sch√©ma SQL dans `supabase/migrations/` est **100% r√©utilisable** !

```bash
# Copier toutes les migrations
cp -r supabase/migrations/ backend/migrations/

# Adapter si n√©cessaire (enlever les sp√©cificit√©s Supabase)
```

**Ce qui est r√©utilisable √† 100% :**
- ‚úÖ Toutes les tables (profiles, jobs, applications, etc.)
- ‚úÖ Toutes les colonnes
- ‚úÖ Toutes les relations (foreign keys)
- ‚úÖ Tous les index
- ‚úÖ La logique m√©tier (triggers, fonctions SQL)

**Ce qui doit √™tre r√©impl√©ment√© :**
- ‚ùå Row Level Security (RLS) ‚Üí Middleware d'autorisation dans votre backend
- ‚ùå Supabase Auth ‚Üí Votre syst√®me d'auth (JWT custom)
- ‚ùå Real-time ‚Üí WebSockets custom ou service tiers (Socket.io, Pusher)
- ‚ùå Storage ‚Üí AWS S3 ou autre

#### √âtape 2 : Cr√©er les API Endpoints

Votre backend doit impl√©menter les m√™mes endpoints. Voir section [Contrats API](#contrats-api-pour-l√©quipe-backend).

#### √âtape 3 : Remplacer les Services Frontend

Cr√©er un **nouveau layer d'abstraction** :

```typescript
// src/lib/api.ts (NOUVEAU FICHIER)
const API_BASE_URL = import.meta.env.VITE_API_URL;

export const api = {
  async get(endpoint: string) {
    const token = localStorage.getItem('auth_token');
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }

    return response.json();
  },

  async post(endpoint: string, data: any) {
    const token = localStorage.getItem('auth_token');
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }

    return response.json();
  },

  async put(endpoint: string, data: any) {
    const token = localStorage.getItem('auth_token');
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }

    return response.json();
  },

  async delete(endpoint: string) {
    const token = localStorage.getItem('auth_token');
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }

    return response.json();
  }
};
```

Puis **remplacer progressivement** chaque service :

```typescript
// AVANT
// src/services/profileService.ts
import { supabase } from '../lib/supabase';

export const getProfile = async (userId: string) => {
  const { data } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .single();
  return data;
};

// APR√àS
// src/services/profileService.ts
import { api } from '../lib/api';

export const getProfile = async (userId: string) => {
  return await api.get(`/profiles/${userId}`);
};
```

#### √âtape 4 : Adapter l'Authentification

```typescript
// AVANT
// src/contexts/AuthContext.tsx
const { data } = await supabase.auth.signInWithPassword({
  email,
  password
});

// APR√àS
// src/contexts/AuthContext.tsx
const response = await fetch(`${API_URL}/auth/login`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password })
});

const { token, user } = await response.json();
localStorage.setItem('auth_token', token);
```

---

## üîÄ Option 2 : Architecture Hybride (Temporaire)

Si migration progressive souhait√©e :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               ARCHITECTURE HYBRIDE                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FRONTEND                                               ‚îÇ
‚îÇ     ‚Üì ‚Üì ‚Üì                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ Votre Backend API‚îÇ  ‚îÇ Supabase (Auth)  ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ - Jobs           ‚îÇ  ‚îÇ - sign_in        ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ - Profiles       ‚îÇ  ‚îÇ - sign_up        ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ - Applications   ‚îÇ  ‚îÇ - JWT tokens     ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ - Messages       ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                   ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  Votre Base de Donn√©es                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantage** : Garde l'auth Supabase (simple et s√©curis√©)
**Inconv√©nient** : D√©pendance √† Supabase reste

---

## üìù Contrats API pour l'√âquipe Backend

### Endpoints Essentiels √† Impl√©menter

#### 1. **Authentification**

```
POST /auth/register
Body: { email, password, user_type: 'athlete' | 'company' }
Response: { token, user: { id, email, user_type } }

POST /auth/login
Body: { email, password }
Response: { token, user: { id, email, user_type } }

POST /auth/logout
Headers: Authorization: Bearer {token}
Response: { success: true }

GET /auth/me
Headers: Authorization: Bearer {token}
Response: { user: { id, email, user_type, ... } }

POST /auth/forgot-password
Body: { email }
Response: { success: true, message: 'Email sent' }

POST /auth/reset-password
Body: { token, new_password }
Response: { success: true }
```

#### 2. **Profils**

```
GET /profiles/:userId
Response: { id, email, user_type, created_at, ... }

PUT /profiles/:userId
Body: { first_name, last_name, ... }
Response: { updated profile }

GET /profiles/athlete/:userId
Response: { athlete_profile data }

PUT /profiles/athlete/:userId
Body: { sport, position, height, weight, ... }
Response: { updated athlete_profile }

GET /profiles/company/:userId
Response: { company_profile data }

PUT /profiles/company/:userId
Body: { company_name, sector, ... }
Response: { updated company_profile }
```

#### 3. **Offres d'Emploi**

```
GET /jobs
Query: ?sector=sport&location=Paris&limit=20&offset=0
Response: { jobs: [...], total_count, page, limit }

GET /jobs/:jobId
Response: { job details with company info }

POST /jobs
Body: { title, description, requirements, salary_min, salary_max, ... }
Headers: Authorization (company only)
Response: { created job }

PUT /jobs/:jobId
Body: { updated fields }
Headers: Authorization (company owner only)
Response: { updated job }

DELETE /jobs/:jobId
Headers: Authorization (company owner only)
Response: { success: true }

GET /jobs/company/:companyId
Response: { jobs: [...] }
```

#### 4. **Candidatures**

```
GET /applications
Query: ?athlete_id=xxx or ?job_id=xxx
Response: { applications: [...] }

POST /applications
Body: { job_id, cover_letter, resume_url }
Headers: Authorization (athlete only)
Response: { created application }

PUT /applications/:applicationId
Body: { status: 'pending' | 'reviewing' | 'accepted' | 'rejected' }
Headers: Authorization (company or athlete)
Response: { updated application }

GET /applications/:applicationId
Response: { application with job and athlete details }
```

#### 5. **Messages**

```
GET /messages
Query: ?user_id=xxx
Response: { conversations: [...] }

POST /messages
Body: { recipient_id, subject, content }
Headers: Authorization
Response: { created message }

GET /messages/:messageId
Headers: Authorization
Response: { message details }

PUT /messages/:messageId/read
Headers: Authorization
Response: { success: true }

GET /messages/conversation/:userId
Headers: Authorization
Response: { messages between auth user and userId }
```

#### 6. **Feature Flags**

```
GET /features
Response: { categories, versions, flags }

GET /features/user/:userId
Headers: Authorization
Response: { enabled_features: [...] }

PUT /features/:featureId
Body: { is_enabled, rollout_percentage }
Headers: Authorization (admin only)
Response: { updated feature }

POST /features/:featureId/beta-access
Body: { user_id, access_type: 'beta' | 'early_access' | 'preview' }
Headers: Authorization (admin only)
Response: { success: true }
```

#### 7. **Contextes Multi-R√¥les**

```
GET /contexts/user/:userId
Headers: Authorization
Response: { contexts: [...] }

GET /contexts/:contextId
Headers: Authorization
Response: { context details with permissions }

POST /organizations
Body: { name, slug, company_profile_id }
Headers: Authorization (company only)
Response: { created organization }

POST /organizations/:orgId/invite
Body: { email, role: 'owner' | 'hr_manager' | 'hr_recruiter' | ... }
Headers: Authorization (owner only)
Response: { invitation sent }

POST /delegations
Body: { athlete_profile_id, delegate_email, role: 'guardian' | 'agent' | 'manager' }
Headers: Authorization (athlete or guardian only)
Response: { delegation created }

GET /organizations/:orgId/members
Headers: Authorization
Response: { members: [...] }

GET /delegations/athlete/:athleteId
Headers: Authorization
Response: { delegates: [...] }
```

#### 8. **T√¢ches Partag√©es**

```
GET /tasks
Query: ?context_type=organization&context_id=xxx
Response: { tasks: [...] }

POST /tasks
Body: { context_type, context_id, title, description, assigned_to, priority, due_date }
Headers: Authorization
Response: { created task }

PUT /tasks/:taskId
Body: { status, assigned_to, ... }
Headers: Authorization
Response: { updated task }

POST /tasks/:taskId/comments
Body: { content }
Headers: Authorization
Response: { created comment }

GET /tasks/my
Headers: Authorization
Response: { tasks assigned to auth user }
```

#### 9. **Messages Contextuels**

```
GET /context-messages
Query: ?context_type=organization&context_id=xxx
Response: { messages: [...] }

POST /context-messages
Body: { context_type, context_id, subject, content, visibility }
Headers: Authorization
Response: { created message }

GET /context-messages/unread-count
Headers: Authorization
Response: { count: 5 }
```

#### 10. **Admin**

```
GET /admin/users
Query: ?page=1&limit=50&search=john
Response: { users: [...], total, page, limit }
Headers: Authorization (admin only)

PUT /admin/users/:userId
Body: { status: 'active' | 'suspended', permissions }
Headers: Authorization (super_admin only)
Response: { updated user }

GET /admin/analytics
Response: {
  total_users,
  active_jobs,
  total_applications,
  users_by_type,
  jobs_by_sector,
  ...
}
Headers: Authorization (admin only)

POST /admin/features/:featureId/enable
Headers: Authorization (super_admin only)
Response: { success: true }
```

### Format des R√©ponses

**Succ√®s** :
```json
{
  "success": true,
  "data": { ... }
}
```

**Erreur** :
```json
{
  "success": false,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "Email ou mot de passe incorrect",
    "details": {} // optionnel
  }
}
```

### Authentification

**JWT Token** dans le header :
```
Authorization: Bearer your-jwt-token-here
```

**Payload JWT recommand√©** :
```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "user_type": "athlete",
  "iat": 1234567890,
  "exp": 1234567890
}
```

### Pagination

Format standard :
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "total_pages": 8
  }
}
```

---

## üîß Guide de Migration Supabase ‚Üí Backend Custom

### Fichiers √† Modifier

```
trophenix/
‚îú‚îÄ src/
‚îÇ  ‚îú‚îÄ lib/
‚îÇ  ‚îÇ  ‚îú‚îÄ supabase.ts ‚Üí ‚ùå √Ä SUPPRIMER
‚îÇ  ‚îÇ  ‚îî‚îÄ api.ts ‚Üí ‚úÖ NOUVEAU (client API)
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ services/
‚îÇ  ‚îÇ  ‚îú‚îÄ authService.ts ‚Üí üîÑ MODIFIER (appels API)
‚îÇ  ‚îÇ  ‚îú‚îÄ profileService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îú‚îÄ jobService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îú‚îÄ messageService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îú‚îÄ adminService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îú‚îÄ contextService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îú‚îÄ featureService.ts ‚Üí üîÑ MODIFIER
‚îÇ  ‚îÇ  ‚îî‚îÄ ... (tous les services)
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ contexts/
‚îÇ  ‚îÇ  ‚îî‚îÄ AuthContext.tsx ‚Üí üîÑ MODIFIER (nouvelle logique auth)
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ .env ‚Üí üîÑ MODIFIER
‚îÇ     ‚îú‚îÄ VITE_API_URL=https://api.trophenix.com
‚îÇ     ‚îî‚îÄ (supprimer VITE_SUPABASE_*)
```

### Checklist de Migration par Service

#### ‚úÖ AuthService

**AVANT (Supabase)** :
```typescript
const { data, error } = await supabase.auth.signInWithPassword({
  email,
  password
});
```

**APR√àS (API Backend)** :
```typescript
const response = await api.post('/auth/login', { email, password });
const { token, user } = response.data;
localStorage.setItem('auth_token', token);
```

**Fonctions √† migrer** :
- [ ] `signUp()` ‚Üí `POST /auth/register`
- [ ] `signIn()` ‚Üí `POST /auth/login`
- [ ] `signOut()` ‚Üí `POST /auth/logout`
- [ ] `getCurrentUser()` ‚Üí `GET /auth/me`
- [ ] `resetPassword()` ‚Üí `POST /auth/reset-password`

#### ‚úÖ ProfileService

**AVANT** :
```typescript
const { data } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', userId)
  .single();
```

**APR√àS** :
```typescript
const data = await api.get(`/profiles/${userId}`);
```

**Fonctions √† migrer** :
- [ ] `getProfile()` ‚Üí `GET /profiles/:id`
- [ ] `updateProfile()` ‚Üí `PUT /profiles/:id`
- [ ] `getAthleteProfile()` ‚Üí `GET /profiles/athlete/:id`
- [ ] `updateAthleteProfile()` ‚Üí `PUT /profiles/athlete/:id`
- [ ] `getCompanyProfile()` ‚Üí `GET /profiles/company/:id`
- [ ] `updateCompanyProfile()` ‚Üí `PUT /profiles/company/:id`

#### ‚úÖ JobService

**Fonctions √† migrer** :
- [ ] `getAllJobs()` ‚Üí `GET /jobs`
- [ ] `getJobById()` ‚Üí `GET /jobs/:id`
- [ ] `createJob()` ‚Üí `POST /jobs`
- [ ] `updateJob()` ‚Üí `PUT /jobs/:id`
- [ ] `deleteJob()` ‚Üí `DELETE /jobs/:id`
- [ ] `getCompanyJobs()` ‚Üí `GET /jobs/company/:companyId`

#### ‚úÖ MessageService

- [ ] `getMessages()` ‚Üí `GET /messages`
- [ ] `sendMessage()` ‚Üí `POST /messages`
- [ ] `markAsRead()` ‚Üí `PUT /messages/:id/read`
- [ ] `getConversation()` ‚Üí `GET /messages/conversation/:userId`

#### ‚úÖ FeatureService

- [ ] `getAllFeatures()` ‚Üí `GET /features`
- [ ] `getEnabledFeaturesForUser()` ‚Üí `GET /features/user/:userId`
- [ ] `updateFeatureStatus()` ‚Üí `PUT /features/:id`
- [ ] `grantBetaAccess()` ‚Üí `POST /features/:id/beta-access`

#### ‚úÖ ContextService

- [ ] `getUserContexts()` ‚Üí `GET /contexts/user/:userId`
- [ ] `createOrganization()` ‚Üí `POST /organizations`
- [ ] `inviteMember()` ‚Üí `POST /organizations/:id/invite`
- [ ] `createDelegation()` ‚Üí `POST /delegations`

### Script de Migration Semi-Automatique

```bash
#!/bin/bash
# scripts/migrate-services.sh

# Remplacer import supabase par api
find src/services -type f -name "*.ts" -exec sed -i '' 's/from "..\/lib\/supabase"/from "..\/lib\/api"/g' {} +
find src/services -type f -name "*.ts" -exec sed -i '' 's/{ supabase }/{ api }/g' {} +

echo "‚úÖ Imports modifi√©s"
echo "‚ö†Ô∏è  Review manuel n√©cessaire pour les appels Supabase"
echo "üìù Voir z_README_MIGRATION_SUPABASE_TO_BACKEND.md pour d√©tails"
```

---

## ‚òÅÔ∏è D√©ploiement AWS

### Architecture AWS Recommand√©e

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AWS ARCHITECTURE                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  Route 53 (DNS)                                         ‚îÇ
‚îÇ  ‚îú‚îÄ trophenix.com ‚Üí CloudFront                         ‚îÇ
‚îÇ  ‚îî‚îÄ api.trophenix.com ‚Üí ALB                            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  CloudFront (CDN) ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îÇ
‚îÇ  ‚îî‚îÄ Cache global du frontend       ‚îÇ                   ‚îÇ
‚îÇ         ‚Üì                           ‚îÇ                   ‚îÇ
‚îÇ  S3 Bucket (Frontend Static)       ‚îÇ                   ‚îÇ
‚îÇ  ‚îî‚îÄ index.html, assets/            ‚îÇ                   ‚îÇ
‚îÇ                                    ‚îÇ                   ‚îÇ
‚îÇ  Application Load Balancer         ‚îÇ                   ‚îÇ
‚îÇ  ‚îú‚îÄ SSL/TLS Termination           ‚îÇ                   ‚îÇ
‚îÇ  ‚îî‚îÄ Health checks                  ‚îÇ                   ‚îÇ
‚îÇ         ‚Üì                           ‚îÇ                   ‚îÇ
‚îÇ  ECS Fargate (Backend API) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ
‚îÇ  ‚îú‚îÄ Auto-scaling (2-10 tasks)                          ‚îÇ
‚îÇ  ‚îú‚îÄ Docker container                                    ‚îÇ
‚îÇ  ‚îî‚îÄ Environment variables (SSM)                         ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  RDS PostgreSQL (Multi-AZ)                             ‚îÇ
‚îÇ  ‚îú‚îÄ Automated backups (7 days)                         ‚îÇ
‚îÇ  ‚îú‚îÄ Read replicas                                      ‚îÇ
‚îÇ  ‚îî‚îÄ Encryption at rest                                 ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  S3 (File Storage)                                     ‚îÇ
‚îÇ  ‚îî‚îÄ User uploads, documents                            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  ElastiCache Redis (Optionnel)                         ‚îÇ
‚îÇ  ‚îî‚îÄ Sessions, cache                                    ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  CloudWatch (Monitoring)                               ‚îÇ
‚îÇ  ‚îú‚îÄ Logs                                               ‚îÇ
‚îÇ  ‚îú‚îÄ Metrics                                            ‚îÇ
‚îÇ  ‚îî‚îÄ Alarms                                             ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### √âtapes de D√©ploiement

#### 1. Frontend sur S3 + CloudFront

```bash
# Build du frontend
npm run build

# Cr√©er un bucket S3
aws s3 mb s3://trophenix-frontend --region eu-west-1

# Configurer le bucket pour hosting
aws s3 website s3://trophenix-frontend \
  --index-document index.html \
  --error-document index.html

# Configurer les permissions
cat > bucket-policy.json <<EOF
{
  "Version": "2012-10-17",
  "Statement": [{
    "Sid": "PublicReadGetObject",
    "Effect": "Allow",
    "Principal": "*",
    "Action": "s3:GetObject",
    "Resource": "arn:aws:s3:::trophenix-frontend/*"
  }]
}
EOF

aws s3api put-bucket-policy \
  --bucket trophenix-frontend \
  --policy file://bucket-policy.json

# Upload des fichiers
aws s3 sync dist/ s3://trophenix-frontend --delete

# Cr√©er une distribution CloudFront
aws cloudfront create-distribution \
  --origin-domain-name trophenix-frontend.s3.amazonaws.com \
  --default-root-object index.html
```

**Configuration CloudFront recommand√©e** :
- ‚úÖ HTTPS obligatoire (redirections auto)
- ‚úÖ Compression Gzip/Brotli
- ‚úÖ Cache des assets (31536000 secondes)
- ‚úÖ Cache HTML (0 secondes ou 300)
- ‚úÖ Custom error responses (404 ‚Üí /index.html)

#### 2. Backend sur ECS Fargate

**Dockerfile exemple (Node.js)** :
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

**D√©ploiement** :
```bash
# Build et push l'image Docker
docker build -t trophenix-api .

# Cr√©er un registry ECR
aws ecr create-repository --repository-name trophenix-api

# Login √† ECR
aws ecr get-login-password --region eu-west-1 | \
  docker login --username AWS --password-stdin \
  123456789.dkr.ecr.eu-west-1.amazonaws.com

# Tag et push
docker tag trophenix-api:latest \
  123456789.dkr.ecr.eu-west-1.amazonaws.com/trophenix-api:latest

docker push 123456789.dkr.ecr.eu-west-1.amazonaws.com/trophenix-api:latest

# Cr√©er le cluster ECS
aws ecs create-cluster --cluster-name trophenix-cluster

# Cr√©er la task definition (voir task-def.json)
aws ecs register-task-definition --cli-input-json file://task-def.json

# Cr√©er le service ECS
aws ecs create-service \
  --cluster trophenix-cluster \
  --service-name api \
  --task-definition trophenix-api:1 \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=ENABLED}"
```

#### 3. Base de Donn√©es RDS

```bash
# Cr√©er une instance RDS PostgreSQL
aws rds create-db-instance \
  --db-instance-identifier trophenix-db \
  --db-instance-class db.t3.medium \
  --engine postgres \
  --engine-version 15.3 \
  --master-username admin \
  --master-user-password "YourSecurePassword123!" \
  --allocated-storage 100 \
  --storage-type gp3 \
  --multi-az \
  --backup-retention-period 7 \
  --vpc-security-group-ids sg-xxx \
  --db-subnet-group-name trophenix-db-subnet

# Attendre que l'instance soit disponible
aws rds wait db-instance-available --db-instance-identifier trophenix-db

# R√©cup√©rer l'endpoint
aws rds describe-db-instances \
  --db-instance-identifier trophenix-db \
  --query 'DBInstances[0].Endpoint.Address'

# Migrer le sch√©ma
# Exporter depuis Supabase :
pg_dump -h xxx.supabase.co -U postgres -d postgres \
  --schema-only --no-owner --no-acl > schema.sql

# Importer dans RDS :
psql -h trophenix-db.xxx.rds.amazonaws.com -U admin -d trophenix < schema.sql

# Migrer les donn√©es (si n√©cessaire)
pg_dump -h xxx.supabase.co -U postgres -d postgres \
  --data-only --no-owner --no-acl > data.sql

psql -h trophenix-db.xxx.rds.amazonaws.com -U admin -d trophenix < data.sql
```

#### 4. Variables d'Environnement

**Frontend (.env.production)** :
```env
VITE_API_URL=https://api.trophenix.com
VITE_ENV=production
```

**Backend (AWS Systems Manager Parameter Store)** :
```bash
# Database URL
aws ssm put-parameter \
  --name /trophenix/DATABASE_URL \
  --value "postgres://admin:pass@trophenix-db.xxx.rds.amazonaws.com:5432/trophenix" \
  --type SecureString

# JWT Secret
aws ssm put-parameter \
  --name /trophenix/JWT_SECRET \
  --value "your-super-secret-jwt-key-min-32-chars" \
  --type SecureString

# AWS S3 Bucket
aws ssm put-parameter \
  --name /trophenix/S3_BUCKET \
  --value "trophenix-uploads" \
  --type String

# R√©cup√©rer dans le backend :
# const DB_URL = await getParameter('/trophenix/DATABASE_URL');
```

#### 5. Load Balancer + Route 53

```bash
# Cr√©er un ALB
aws elbv2 create-load-balancer \
  --name trophenix-alb \
  --subnets subnet-xxx subnet-yyy \
  --security-groups sg-xxx

# Cr√©er un target group
aws elbv2 create-target-group \
  --name trophenix-api-tg \
  --protocol HTTP \
  --port 3000 \
  --vpc-id vpc-xxx \
  --health-check-path /health

# Cr√©er un listener HTTPS
aws elbv2 create-listener \
  --load-balancer-arn arn:aws:elasticloadbalancing:... \
  --protocol HTTPS \
  --port 443 \
  --certificates CertificateArn=arn:aws:acm:... \
  --default-actions Type=forward,TargetGroupArn=arn:...

# Configurer Route 53
aws route53 change-resource-record-sets \
  --hosted-zone-id Z123456 \
  --change-batch file://route53-changes.json
```

### Co√ªts Estim√©s AWS (Mensuel)

| Service | Configuration | Co√ªt estim√© |
|---------|--------------|-------------|
| **S3 + CloudFront** | 10 GB storage, 100k req/mois | ~5‚Ç¨ |
| **ECS Fargate** | 2 t√¢ches 0.5 vCPU, 1GB RAM | ~30‚Ç¨ |
| **RDS PostgreSQL** | db.t3.medium, Multi-AZ, 100GB | ~120‚Ç¨ |
| **Application Load Balancer** | ALB standard | ~20‚Ç¨ |
| **Route 53** | Hosted zone + queries | ~1‚Ç¨ |
| **CloudWatch** | Logs + monitoring | ~5‚Ç¨ |
| **Data Transfer** | 100 GB/mois | ~10‚Ç¨ |
| **TOTAL (Production)** | | **~190‚Ç¨/mois** |

**Alternative moins ch√®re (MVP/Startup)** :
- EC2 t3.medium (~30‚Ç¨) + PostgreSQL sur m√™me instance
- S3 + CloudFront (~5‚Ç¨)
- Route 53 (~1‚Ç¨)
- **Total : ~35-40‚Ç¨/mois**

---

## ‚úÖ Checklist de Migration

### Phase 1 : Pr√©paration (1-2 jours)

- [ ] Lire cette documentation compl√®tement
- [ ] D√©cider de l'architecture (Option 1 recommand√©e)
- [ ] Pr√©parer l'environnement AWS (compte, VPC, subnets)
- [ ] Exporter le sch√©ma SQL de Supabase
- [ ] Exporter les donn√©es de Supabase (si n√©cessaire)
- [ ] D√©finir les contrats API avec l'√©quipe backend
- [ ] Cr√©er un repo backend (si pas existant)

### Phase 2 : Backend (1-2 semaines)

- [ ] Cr√©er la base de donn√©es (RDS PostgreSQL ou autre)
- [ ] Importer le sch√©ma SQL
- [ ] Importer les donn√©es (si n√©cessaire)
- [ ] Impl√©menter les endpoints API Auth
- [ ] Impl√©menter les endpoints API Profils
- [ ] Impl√©menter les endpoints API Jobs
- [ ] Impl√©menter les endpoints API Applications
- [ ] Impl√©menter les endpoints API Messages
- [ ] Impl√©menter les endpoints API Contexts
- [ ] Impl√©menter les endpoints API Features
- [ ] Impl√©menter les endpoints API Admin
- [ ] Impl√©menter l'authentification JWT
- [ ] Impl√©menter les middlewares d'autorisation (√©quivalent RLS)
- [ ] Tests unitaires endpoints critiques
- [ ] Tests d'int√©gration
- [ ] Documentation API (Swagger/OpenAPI)

### Phase 3 : Frontend (3-5 jours)

- [ ] Cr√©er `src/lib/api.ts` (client API)
- [ ] Cr√©er `.env.local` avec VITE_API_URL
- [ ] Migrer `authService.ts`
- [ ] Migrer `AuthContext.tsx`
- [ ] Tester login/logout/register
- [ ] Migrer `profileService.ts`
- [ ] Migrer `jobService.ts`
- [ ] Migrer `messageService.ts`
- [ ] Migrer `contextService.ts`
- [ ] Migrer `featureService.ts`
- [ ] Migrer `adminService.ts`
- [ ] Migrer tous les autres services
- [ ] Supprimer `src/lib/supabase.ts`
- [ ] Tests manuels complets (toutes les features)
- [ ] Tests automatis√©s (si existants)
- [ ] Fix des bugs trouv√©s

### Phase 4 : Staging (2-3 jours)

- [ ] Cr√©er environnement de staging AWS
- [ ] D√©ployer backend sur ECS staging
- [ ] D√©ployer frontend sur S3 staging
- [ ] Configurer RDS staging (ou DB test)
- [ ] Tests end-to-end en staging
- [ ] Performance testing
- [ ] Security testing
- [ ] Load testing (si n√©cessaire)
- [ ] Fix des bugs trouv√©s

### Phase 5 : Production (1-2 jours)

- [ ] Cr√©er bucket S3 production
- [ ] Cr√©er distribution CloudFront
- [ ] Cr√©er RDS PostgreSQL production (Multi-AZ)
- [ ] Cr√©er cluster ECS production
- [ ] Configurer ALB production
- [ ] Configurer Route 53
- [ ] Configurer SSL/TLS (ACM)
- [ ] Configurer CloudWatch alarms
- [ ] Configurer backups automatiques
- [ ] Variables d'environnement production (SSM)
- [ ] Migration des donn√©es Supabase ‚Üí RDS
- [ ] D√©ployer backend production
- [ ] Build et d√©ployer frontend production
- [ ] Tests smoke en production
- [ ] Monitoring post-d√©ploiement
- [ ] Communiquer aux utilisateurs

### Phase 6 : Post-Migration (ongoing)

- [ ] Monitoring quotidien (CloudWatch, logs)
- [ ] Backups v√©rifi√©s
- [ ] Plan de disaster recovery test√©
- [ ] Documentation √©quipe √† jour
- [ ] D√©sactiver Supabase (apr√®s p√©riode de s√©curit√©)
- [ ] Optimisations performance
- [ ] Optimisations co√ªts AWS
- [ ] Security audit

---

## üìä Comparaison : Supabase vs Backend Custom

| Crit√®re | Supabase | Backend Custom (AWS) |
|---------|----------|----------------------|
| **Temps de dev** | ‚úÖ Tr√®s rapide (tout inclus) | ‚ö†Ô∏è Plus long (3-4 semaines) |
| **Contr√¥le** | ‚ö†Ô∏è Limit√© au framework Supabase | ‚úÖ Total sur toute la stack |
| **Co√ªts Startup** | ‚úÖ Gratuit jusqu'√† 50k users | ‚ö†Ô∏è ~35-40‚Ç¨/mois minimum |
| **Co√ªts Scale** | ‚ùå Tr√®s cher (>500‚Ç¨/mois vite atteint) | ‚úÖ Optimisable (~190‚Ç¨/mois stable) |
| **S√©curit√©** | ‚úÖ RLS int√©gr√© puissant | ‚ö†Ô∏è √Ä impl√©menter (middleware auth) |
| **Real-time** | ‚úÖ Natif (PostgreSQL subscriptions) | ‚ùå √Ä impl√©menter (WebSockets) |
| **Auth** | ‚úÖ Complet (email, OAuth, MFA) | ‚ö†Ô∏è √Ä impl√©menter (JWT custom) |
| **Storage** | ‚úÖ Int√©gr√© (S3-like) | ‚úÖ AWS S3 natif |
| **Flexibilit√©** | ‚ö†Ô∏è Limit√©e au SDK Supabase | ‚úÖ Totale (n'importe quel framework) |
| **Vendor lock-in** | ‚ùå Fort (migrations difficiles) | ‚úÖ Aucun (infrastructure standard) |
| **Scalabilit√©** | ‚úÖ Auto (mais co√ªteuse) | ‚úÖ Manuelle mais optimisable |
| **Latence** | ‚ö†Ô∏è D√©pend de la r√©gion Supabase | ‚úÖ Contr√¥lable (r√©gions AWS) |
| **Maintenance** | ‚úÖ Z√©ro (manag√©) | ‚ö†Ô∏è √Ä g√©rer (updates, patches) |
| **Support** | ‚ö†Ô∏è Community (Pro $25/mois) | ‚úÖ AWS Support (si souscrit) |

---

## üéØ Recommandation Finale

### Vous avez D√âJ√Ä un backend ‚Üí **MIGRATION COMPL√àTE**

**Pourquoi ?**
1. ‚úÖ Coh√©rence avec votre stack existante
2. ‚úÖ Pas de vendor lock-in
3. ‚úÖ Contr√¥le total (co√ªts, perf, s√©curit√©)
4. ‚úÖ Tout le frontend est r√©utilisable (juste services √† changer)
5. ‚úÖ Votre √©quipe conna√Æt d√©j√† le backend

**Effort estim√©** :
- Backend API : 1-2 semaines
- Migration frontend : 3-5 jours
- D√©ploiement AWS : 2-3 jours
- **Total : 3-4 semaines**

### Vous n'avez PAS de backend ‚Üí **GARDER SUPABASE**

**Pourquoi ?**
1. ‚úÖ Tout fonctionne d√©j√†
2. ‚úÖ Pas d'effort de migration
3. ‚úÖ Focus sur les features business
4. ‚ö†Ô∏è Migrer plus tard si n√©cessaire (scaling)

---

## üìû Documents √† Partager avec l'√âquipe Backend

### 1. Ce document
**`z_README_MIGRATION_SUPABASE_TO_BACKEND.md`**
- Architecture actuelle et cible
- Contrats API d√©taill√©s
- Guide de migration

### 2. Le sch√©ma de donn√©es
**`supabase/migrations/*.sql`**
- Toutes les tables
- Toutes les relations
- Tous les index
- Fonctions SQL (√† adapter)

### 3. Les types TypeScript
**`src/types/*.ts`**
- Types de toutes les entit√©s
- Utile pour g√©n√©rer les mod√®les backend

### 4. Documentation des fonctionnalit√©s
**`ARCHITECTURE_MULTI_ROLES_ELEA.md`**
- Syst√®me multi-r√¥les expliqu√©
- Contextes et permissions
- Cas d'usage

**`z_README_FEATURE_FLAGS.md`**
- Syst√®me de feature flags
- Comment g√©rer les versions

---

## üöÄ Conclusion

Cette migration est **totalement faisable** en 3-4 semaines avec une √©quipe comp√©tente.

**Points cl√©s** :
- ‚úÖ Le frontend est **100% r√©utilisable**
- ‚úÖ Le sch√©ma SQL est **100% r√©utilisable**
- ‚úÖ Seuls les **services** doivent √™tre refactoris√©s
- ‚úÖ L'architecture cible est **standard et scalable**
- ‚úÖ AWS offre **plus de contr√¥le** et **meilleure scalabilit√©**

**Prochaines √©tapes** :
1. Valider l'approche avec l'√©quipe
2. Planifier le sprint de migration
3. Commencer par le backend (endpoints API)
4. Migrer le frontend progressivement
5. Tester en staging
6. D√©ployer en production

**Bonne migration ! üöÄ**

---

**Questions ? Relire ce document et consulter les migrations SQL !**
